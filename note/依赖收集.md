# 依赖收集

前面我们实现了：

- 数据的劫持
- 模板解析

但是目前我们去更新数据，视图不能正常去更新，如何知道视图是否需要更新，是不是任意一组data数据修改都需要重新渲染更新视图？其实并不是，只有那些在页面被引用的数据变更后才会需要视图的更新，所以需要记录哪些数据是否被引用，被谁引用，从而决定是否更新，更新谁，这也就是依赖收集的目的。



这里需要使用发布-订阅模式来收集我们的依赖，我们先简单实现一个简单的发布订阅，新建一个`dep.js`:

```javascript
class Dep {
  constructor() {
    this.subs = []
  }

  addSub(watcher) {
    this.subs.push(watcher)
  }

  notify() {
    this.subs.forEach(watcher => watcher.update())
  }
}

const dep = new Dep()
dep.addSub({
  update() {
    console.log('1')
  }
})
dep.addSub({
  update() {
    console.log('2')
  }
})
dep.notify()
```

此时我们去调用`notify`的话，会依次输出`1, 2`，这里的`dep`就相当于发布者，`watcher`就属于订阅者，当执行`notify`时，所有的`watcher`都会收到通知，并且执行自己的`update`方法。



所以基于发布-订阅模式，我们就要考虑我们需要在哪去对我们的数据进行发布订阅，可以想到我们之前都对我们的数据都添加了`getter`和`setter`，可以在`getter`的时候调用`dep.addSub()`，在`setter`的时候去调用`dep.notify()`，但是以什么样的方式去添加订阅。我们之前在`$mount`的时候实现了一个渲染`watcher`，现在我们去修改一下这个`watcher`。首先给`Dep`添加两个方法，用来操作`subs`:

```javascript
let stack = [];
export function pushTarget(watcher) {
  Dep.target = watcher;
  stack.push(watcher);
}

export function popTarget() {
  stack.pop();
  Dep.target = stack[stack.length - 1]; 
}
```



然后去修改一下`watcher`:

```javascript
class Watcher { // 每次产生一个watch 都会有一个唯一的标识
  ...
  get() {
+    pushTarget(this); // 让 Dep.target = 这个渲染Watcher，如果数据变化，让watcher重新执行
    this.getter && this.getter(); // 让传入的函数执行
+    popTarget();
  }
+  update() {
+    console.log('数据更新');
+    this.get();
+  }
}
```

然后去修改`defineReactive`方法，添加`addSub`和`dep.notify()`。

```javascript
export function defineReactive(data, key, value) {
  observe(value);   // 如果value依旧是一个对象，需要深度递归劫持
+  const dep = new Dep()
  Object.defineProperty(data, key, {
    get() {
      // 取数据的时候进行依赖收集
+      if (Dep.target) {
+        dep.addSub(Dep.target)
+      }
      return value;
    },
    set(newValue) {
      if (newValue === value) return;
      observe(newValue); // 如果新设置的值是一个对象， 应该添加监测
      value = newValue;
      // 数据更新 去通知更新视图
+      dep.notify()
    }
  });
}
```

此时我们2s后去更新一下`vm.msg = 'hello world'`,会发现视图已经更新了。